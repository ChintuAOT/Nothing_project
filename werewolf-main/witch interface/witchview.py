import random
import time
import json
import sys
from collections import Counter

# this is a util functions helps to generate the result
## Instruction Required
## Button Required
## Content Required

# this class is for each werewolf agent, like Seer, Hunter, Witch, Villager, Wolf
class WerewolfAgent():
    def __init__(self, name, llm_config,roles, role="Villager",**kwargs):
        self.role = role
        self.roles = roles
        self.name = name
        self.identity = ""
        self.round = 0
        self.llm_config = llm_config
        self.sketch_pad_file = f"{self.name}_sketch_pad.json"
        self.sketch_pad = self.initialize_sketch_pad()
        self.inner_sketch_pad_file = f"{self.name}_inner_sketch_pad.json"
        self.inner_sketch_pad = None
        self.healing = True
        self.poison = True

    def generate_response(self):
        return "Generated by GPT"

    def initialize_sketch_pad(self):
        default_sketch_pad = {
            "name": self.name,
            "role": self.role,
        }

        with open(self.sketch_pad_file, 'w') as file:
            json.dump(default_sketch_pad, file, indent=4)
        return default_sketch_pad
    
    def update_sketch_pad(self):
        with open(self.sketch_pad_file, 'w') as file:
            json.dump(self.sketch_pad, file, indent=4)


    def initial_inner_sketch_pad(self, role):
        with open(f"{role}_inner_sketch_pad.json", "r") as temp:
            data = json.load(temp)  # Load the JSON content into a Python object
        with open(self.inner_sketch_pad_file, 'w') as file:
            json.dump(data, file, indent=4)
        self.inner_sketch_pad = data

    def update_inner_sketch_pad(self):
        with open(self.inner_sketch_pad_file, 'w') as file:
            json.dump(self.inner_sketch_pad, file, indent=4)


    def check_next_player(self, name, alive) -> str:
        next_key = random.choice(name)
        
        return next_key


    def inspect_player(self, player):
        if player:
            time.sleep(1)
            self.update_sketch_pad()
            self.update_inner_sketch_pad()
    
    
    def witch_potion(self, round, isWitchKilled, victims, alive, info_witch):

        if not self.healing and not self.poison:
            return victims
    

        victim_name = victims[0].name
    
        # **Step 1: If the Witch is Targeted**
        if isWitchKilled:
            # If it's the first night, Witch can save herself
            if round == 1:
                print("Button Required: Do you want to use the healing potion?")
                ## add some interaction here. Usually you save yourself
                self.healing = False
                victims.remove(self)  # Remove the witch from victims
                return victims
            
            # **If it's NOT the first night, and the witch is killed, Witch can only use Poison**, but be careful, if wolves can killed two guys under some rules?
            else:
                if self.poison:
                    self.generate_response()
                    print("Button Required: Do you want to use the poison potion?")
                    poisoned_player = random.choice([random.choice(alive), None]) if alive else None
                    if poisoned_player:
                        victims.append(poisoned_player)
                        poisoned_player.update_sketch_pad()
                        # here you should set in the software dashboard to false
                        self.poison = False
                        return victims
                    else:
                        # If Witch does not heal or poison, she dies
                        victims.append(self)
                        return victims
        
                # If Witch does not have poison, she dies
                victims.append(self)
                return victims



        ## GONNA USE INFO_WITCH HERE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        # **Step 2: If Witch is NOT Attacked, She Can Use Healing or Poison**
        if self.healing:
            print("Button Required : choose whether to heal or not")
            response = random.choice([random.choice(victims), "None"])

            ## not decide to heal
            if response == "None":
                if self.poison:
                    print("Button Required : choose who to poison not")
                    poisoned = random.choice([random.choice(alive), "None"])

                    if poisoned != "None":
                        poisoned_player = None
                        for player in alive:
                            if player.name == poisoned:
                                poisoned_player = player

                        if poisoned_player:
                            self.poison = False
                            poisoned_player.update_sketch_pad()
                            victims.append(poisoned_player)
                            return victims
                    
                    else:
                        return victims
                else:
                    return victims

                
            elif response != "None":

                agent = None
                for player in victims:
                    if player.name == response:
                        agent = player
                if agent:
                    victims.remove(agent)
                    self.healing = False
                return victims
            

        # **Step 3: Witch does not has healing potion and Uses Poison**
        elif not self.poison and self.poison:
            
            print("Button Required : choose who to poison or not")
            poisoned = random.choice([random.choice(alive), "None"])
            # this can be a choice from you
            if poisoned != "None":
                poisoned_player = None
                for player in alive:
                    if player.name == poisoned:
                        poisoned_player = player

                self.poison = False
                poisoned_player.update_sketch_pad()
                victims.append(poisoned_player)
                return victims
            else:
                victims.append(self)
                return victims
        else:
            return victims


    def broadcast(self, result, str):
        pass

    def note(self):

        return "GPT Required: Decide who to vote and return the name"
    
    def note(self):
        return f"GPT Required: {self.name} saying note generated by GPT"


    def hunter_action(self, victims, alive):
        # return the player you want to kill by using chatgpt

        huntered = random.choice([random.choice(alive), "None"])
        ##########
        if huntered != "None":
            print(f"GPT Required : {self.name} choose to hunter {huntered}")
        else:
            print(f"GPT Required : {self.name} choose not to hunter")

        if huntered != "None":
            huntered_player = None
            for player in alive:
                if player.name == huntered:
                    huntered_player = player
            return huntered_player
        else:
            return None
        



    def vote_action(self, alive):
        alive_name = [player.name for player in alive]
        print("Button Required : choose who to VOTE or ABSTAIN")

        decision = random.choice([random.choice(alive_name), "None"])
        return decision if decision in alive_name or decision == 'None' else 'None'

'''
roles = ["Villager", "Villager", "Villager", "Hunter", "Seer", "Wolf", "Wolf", "Wolf", "Witch"]

agents = [WerewolfAgent(name=f"Player{i+1}",llm_config = llm_config, roles=roles) for i in range(len(roles))]
'''


class Host():
    def __init__(self, agents, roles):
        self.time = 1
        self.agents = agents
        self.round = 0 
        self.history = ""
        self.roles = roles
        self.alive_for_seer = None
        self.badge = ""
        self.sheriff_round = 0

    def choose_target(self, player_to_kill: list) -> str:
        counts = Counter(player_to_kill)
        max_count = max(counts.values())
        candidates = [player for player, count in counts.items() if count == max_count]
        return random.choice(candidates)
    
    def assign_roles(self):
        """Assign roles randomly to participants."""
        random.shuffle(self.roles)
        wolf_list = []
        wolf_team = []
        for i, agent in enumerate(self.agents):
            agent.role = self.roles[i]
            agent.sketch_pad["role"] = self.roles[i]
            agent.initial_inner_sketch_pad(agent.role)


            if agent.role in ["Seer", "Villager", "Witch", "Hunter"]:
                agent.identity += "good"
            else:
                agent.identity += "bad"
                wolf_list.append(agent)
                wolf_team.append(agent.name)
            
            agent.update_sketch_pad()

            print(agent.name, agent.role, agent.identity)

        print("Roles have been assigned.")


    def start_game(self):
        """Start the Werewolf game sequence."""
        self.assign_roles()
        time.sleep(self.time)
        self.night_phase()
        time.sleep(self.time)

    def night_phase(self):
        self.round += 1
        print(f"Instruction Required : God : This is round {self.round}")

        print("Instruction Required : 🌙 Night falls on the village... Everyone, close your eyes.")


        print(
        """
        Instruction Required :
        God :
            🐺 Wolves, open your eyes.
            - Look around, find your fellow wolves.
            - Silently agree on a villager to eliminate.
            - When you have chosen, point to your target.
            🐺 Wolves, close your eyes.
        """
        )
        alive_wolf = []

        for agent in self.agents:
            if agent.role == "Wolf":
                alive_wolf.append(agent)

        victims = []
        

        victims.append(random.choice(self.agents))

        victims_name = [agent.name for agent in victims]

        alive = [agent for agent in self.agents if agent.name not in victims_name]

        self.check_status(alive)

####################### Seer Part #################################
###################################################################

        print("Instruction Required : Seer please open your eyes")
        print("Instruction Required : Seer Please choose the one you what to check")

        ## change for checking the next player nad player still not checked

####################### Witch Part #################################
###################################################################

        witch = next((agent for agent in self.agents if agent.role == "Witch"), None)  # select until you find seer

        print("Instruction Required : Witch please open your eyes")
        print("Instruction Required: Do you want to use the healing potion?")
        print("Instruction Required: Do you want to use the poison potion?")        

        info_witch = "ignore it"
        if witch:
            isWitchKilled = False
            for i in victims:
                if i.role == "Witch":
                    isWitchKilled = True
        
            victims = witch.witch_potion(self.round, isWitchKilled, victims, alive, info_witch)
            if not victims:
                alive = [agent for agent in self.agents]
            else:
                victims_name = [agent.name for agent in victims]
                alive = [agent for agent in self.agents if agent.name not in victims_name]
            self.check_status(alive)

        print(
        """
            Instruction Required:  HOST: 🌙 Night is over... The village awakens.
            Instruction Required:  HOST: - The narrator will now reveal if someone was eliminated.
        """
        )
        death_information = f"In the round {self.round}, "

        self.day_phase(victims, alive, death_information)


####################### public conversation Part #################################
###################################################################
    def day_phase(self, victims, alive, death_information):  

        ## no sheriffprocess now, do it later



            ## remove the player from the alive part

            ## go to go to the public discussion part???/


        ## origibal part in day_phase: 
        new_victim = None     
        new_broadcast = ""
        if not victims:
            print("Instruction Required: HOST : In the Night, no one is killed")
        else:
            for player in victims:
                if self.round == 1:
                    if player.role == "Witch":
                        print("GPT/ INPUT TEXT REQUIRED: you sohould input your note as a witch or let gpt help you generate.")
                    else: 
                        saying = player.note()
                        print(f"GPT Required: {player.name} is saying the note {saying} here, show in terminal")
                        if player.role == "Hunter":
                            victim = player.hunter_action(victims, alive)
                            if victim:  # Ensure victim is not None
                                victims.append(victim)


                else:
                    if player.role == "Hunter":
                        victim = player.hunter_action(victims, alive)
                        if victim:  # Ensure victim is not None
                            victims.append(victim)


        if victims:
            victims_name = [agent.name for agent in victims]
            alive = [agent for agent in self.agents if agent.name not in victims_name]
        else:

            alive = [agent for agent in self.agents]



        self.agents = alive

        self.check_status()

        ## random start from a people in alive and is in a round sequence for public discussion

        self.public_discussion()


        victim_name = self.vote()
        ############### add a vote session here

        if victim_name != None:
            for player in alive:
                if player.name == victim_name:
                    if player.role == "Witch":
                        print("Input/ GPT Required: Here is banish note for witch, you can type yourself or use the gpt to generate. you should show it in the terminal")
                        print("Instruction Required: You should show it in the terminal")
                    else:    
                        temp_note = player.note()
                        ############ remember to ask the hunter identity here.
                        print(temp_note)
                        print("Instruction: Required : Here is banish note generated by gpt, you should print in the terminal") 

            alive = [agent for agent in self.agents if agent.name not in victim_name]
        else:
            alive = [agent for agent in self.agents]



        self.agents = alive


        self.alive_for_seer = alive

        self.check_status()

        self.night_phase()

    def check_status(self, alive=None):
        if alive is None:
            alive = self.agents  # Assign the correct live agents list

        goodCount = 0
        badCount = 0

        # Count good and bad players
        for player in alive:
            if player.identity == "good":
                goodCount += 1
            else:
                badCount += 1

        # Determine game outcome
        if goodCount == 0:
            print("Werewolves win")
            sys.exit()
        elif badCount == 0:
            print("Villagers win")
            sys.exit()
        


    def vote(self):
        vote_count = {} 
        vote_info = f"In the round {self.round}, "

        # Initialize vote count for each player
        for player in self.agents:
            vote_count[player.name] = 0  

        # Count votes
        for player in self.agents:

            if player.role == "Witch":
                input = player.vote_action(self.agents)
                print("Button Required: ADD THE NAME YOU HAVE CHOSEN FROM THE SOFTWARE LIKE Player1 and input here or abstain")
                if input in vote_count:
                    vote_count[input] += 1
            else:
                key = player.vote_action(self.agents)
                print("GPT REQUIRED: decide who to vote or abstain")
                vote_info += f"{player.name} vote {key}, "
                # add who vote who
                if key in vote_count:
                    vote_count[key] += 1
                else:
                    vote_count[key] = 1  


        # Find the maximum vote count
        max_votes = max(vote_count.values())

        # Get all players who have the maximum vote count
        max_voted_players = [player for player, votes in vote_count.items() if votes == max_votes]

        # Randomly choose one if there's a tie
        chosen_player = random.choice(max_voted_players)

        return chosen_player
    

    def public_discussion(self):
        start_index = random.randint(0, len(self.agents) - 1)
        circular_order = self.agents[start_index:] + self.agents[:start_index]
        print("Host: Let us start the public discussion period!")
        alive_name = [player.name for player in self.agents]
        discussion_log = []  # Store discussions for review
        discussion_round = 0
        allowed_keys = ["Player1", "Player2", "Player3", "Player4", "Player5", "Player6", "Player7", "Player8", "Player9"]

        for agent in circular_order:

            response = agent.generate_response()
            print(f"Instruction Required: {agent.name} said oublic discussion : {response}, and you should pint this in the terminal here.")
    

        
